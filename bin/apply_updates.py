#!/usr/bin/env python3
"""
Apply updates for Minecraft server, Fabric loader, and mods.
Reads update information from a JSON file generated by check_updates.py
"""
import argparse
import json
import sys
import urllib.request
import urllib.error
from pathlib import Path
from typing import Dict, List

# Fix Windows console encoding
if sys.platform == 'win32':
    import os
    os.system('chcp 65001 > nul 2>&1')
    if sys.stdout.encoding != 'utf-8':
        import io
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')


class UpdateApplier:
    """Apply updates based on update information file"""

    def __init__(self, update_file: str = "updates.json", config_file: str = "config.yaml"):
        self.update_data = self._load_update_file(update_file)
        self.config_file = config_file
        self.is_compatibility_report = self.update_data.get('update_type') == 'full_compatibility_check'

    def _load_update_file(self, update_file: str) -> dict:
        """Load JSON update file"""
        try:
            with open(update_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: Update file '{update_file}' not found")
            print("Please run check_updates.py first to generate the update file")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON: {e}")
            sys.exit(1)

    def _download_file(self, url: str, destination: str) -> bool:
        """Download a file from URL to destination"""
        try:
            print(f"  Downloading from {url}...")
            req = urllib.request.Request(url)
            req.add_header('User-Agent', 'minecraft-server-update-applier/1.0')

            with urllib.request.urlopen(req, timeout=30) as response:
                content = response.read()

            with open(destination, 'wb') as f:
                f.write(content)

            print(f"  ✓ Downloaded to {destination}")
            return True

        except Exception as e:
            print(f"  ✗ Error downloading: {e}")
            return False

    def update_minecraft(self, dry_run: bool = False) -> bool:
        """Update Minecraft server"""
        mc_data = self.update_data.get('minecraft', {})

        # Handle compatibility report format
        if self.is_compatibility_report:
            if not self.update_data.get('compatible_update_found'):
                print("  ✗ No compatible update available")
                return False

            current = mc_data.get('current_version')
            target = mc_data.get('target_version')

            print(f"\n  Minecraft server update:")
            print(f"    Current: {current}")
            print(f"    Target:  {target}")

            if dry_run:
                print("  [DRY RUN] Would update Minecraft server")
                return True

            print("\n  ⚠ Minecraft server updates require manual intervention")
            print(f"  Please update config.yaml minecraft.version to {target} and rebuild")
            return True

        # Handle standard update format
        if not mc_data.get('has_update'):
            print("  ✓ Minecraft server is already up to date")
            return True

        current = mc_data.get('current_version')
        latest = mc_data.get('latest_version')

        print(f"\n  Minecraft server update available:")
        print(f"    Current: {current}")
        print(f"    Latest:  {latest}")

        if dry_run:
            print("  [DRY RUN] Would update Minecraft server")
            return True

        print("\n  ⚠ Minecraft server updates require manual intervention")
        print("  Please update config.yaml and rebuild the server")

        return True

    def update_fabric(self, dry_run: bool = False) -> bool:
        """Update Fabric loader"""
        fabric_data = self.update_data.get('fabric', {})

        # Handle compatibility report format
        if self.is_compatibility_report:
            if not self.update_data.get('compatible_update_found'):
                print("  ✗ No compatible update available")
                return False

            current = fabric_data.get('current_version')
            target = fabric_data.get('target_version')

            print(f"\n  Fabric loader update:")
            print(f"    Current: {current}")
            print(f"    Target:  {target}")

            if dry_run:
                print("  [DRY RUN] Would update Fabric loader")
                return True

            print("\n  ⚠ Fabric loader updates require manual intervention")
            print(f"  Please update config.yaml fabric.version to {target} and rebuild")
            return True

        # Handle standard update format
        if not fabric_data.get('has_update'):
            print("  ✓ Fabric loader is already up to date")
            return True

        current = fabric_data.get('current_version')
        latest = fabric_data.get('latest_version')

        print(f"\n  Fabric loader update available:")
        print(f"    Current: {current}")
        print(f"    Latest:  {latest}")

        if dry_run:
            print("  [DRY RUN] Would update Fabric loader")
            return True

        print("\n  ⚠ Fabric loader updates require manual intervention")
        print("  Please update config.yaml and rebuild the server")

        return True

    def update_mods(self, mods_dir: str = "mods", dry_run: bool = False) -> Dict[str, bool]:
        """Update mods"""
        mod_updates = self.update_data.get('mods', {})
        results = {}

        if not mod_updates:
            print("  ✓ All mods are already up to date")
            return results

        print(f"\n  Found {len(mod_updates)} mod update(s)")

        mods_path = Path(mods_dir)
        if not mods_path.exists():
            print(f"  ✗ Mods directory '{mods_dir}' not found")
            return results

        for mod_name, mod_info in mod_updates.items():
            print(f"\n  [{mod_name}]")

            # Handle compatibility report format
            if self.is_compatibility_report:
                version = mod_info.get('version')
                url = mod_info.get('download_url')
                print(f"    Version: {version}")
            else:
                # Handle standard update format
                current = mod_info.get('current_version')
                latest = mod_info.get('latest_version')
                url = mod_info.get('download_url')
                print(f"    {current} → {latest}")

            if dry_run:
                print(f"    [DRY RUN] Would download from {url}")
                results[mod_name] = True
                continue

            # Download the new version
            if url == 'N/A':
                print(f"    ✗ No download URL available")
                results[mod_name] = False
                continue

            # Extract filename from URL or construct it
            filename = url.split('/')[-1]
            if not filename.endswith('.jar'):
                if self.is_compatibility_report:
                    filename = f"{mod_name}-{mod_info['version']}.jar"
                else:
                    filename = f"{mod_name}-{mod_info['latest_version']}.jar"

            destination = mods_path / filename
            success = self._download_file(url, str(destination))
            results[mod_name] = success

        return results

    def update_config(self, updates: Dict[str, str], dry_run: bool = False) -> bool:
        """Update config.yaml with new versions"""
        if not updates:
            return True

        if dry_run:
            print("\n  [DRY RUN] Would update config.yaml with:")
            for component, version in updates.items():
                print(f"    {component}: {version}")
            return True

        try:
            import yaml

            with open(self.config_file, 'r') as f:
                config = yaml.safe_load(f)

            # Update versions in config
            for component, version in updates.items():
                if component == 'minecraft':
                    config['minecraft']['version'] = version
                elif component == 'fabric':
                    config['fabric']['version'] = version

            # Save updated config
            with open(self.config_file, 'w') as f:
                yaml.dump(config, f, default_flow_style=False, sort_keys=False)

            print(f"\n  ✓ Updated {self.config_file}")
            return True

        except Exception as e:
            print(f"\n  ✗ Error updating config: {e}")
            return False


def main():
    parser = argparse.ArgumentParser(
        description='Apply updates to Minecraft server, Fabric loader, and mods'
    )
    parser.add_argument(
        '--input',
        type=str,
        default='updates.json',
        help='Input file with update information (default: updates.json)'
    )
    parser.add_argument(
        '--mods-dir',
        type=str,
        default='mods',
        help='Directory containing mods (default: mods)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be updated without making changes'
    )
    parser.add_argument(
        '--all',
        action='store_true',
        help='Update all components (default)'
    )
    parser.add_argument(
        '--mc',
        action='store_true',
        help='Update only Minecraft server'
    )
    parser.add_argument(
        '--fabric',
        action='store_true',
        help='Update only Fabric loader'
    )
    parser.add_argument(
        '--mods',
        action='store_true',
        help='Update only mods'
    )

    args = parser.parse_args()

    # If no specific flag is set, update all
    update_all = args.all or not (args.mc or args.fabric or args.mods)

    print("="*70)
    print("MINECRAFT SERVER UPDATE APPLIER")
    print("="*70)

    if args.dry_run:
        print("\n⚠ DRY RUN MODE - No changes will be made\n")

    applier = UpdateApplier(args.input)

    print(f"Update file: {args.input}")
    print(f"Generated:   {applier.update_data.get('timestamp', 'Unknown')}")

    if applier.is_compatibility_report:
        print(f"Report type: Full Compatibility Check")
        if not applier.update_data.get('compatible_update_found'):
            print("\n⚠ This report indicates NO compatible update was found")
            print("No updates will be applied.\n")
            return
        else:
            print(f"Status:      Compatible update found")
            tested = applier.update_data.get('tested_versions', {})
            print(f"Tested:      {tested.get('mc_versions_tested', '?')} MC versions, "
                  f"{tested.get('fabric_versions_tested', '?')} Fabric versions")
    else:
        print(f"Report type: Standard Update Check")

    # Update Minecraft
    if update_all or args.mc:
        print("\n" + "-"*70)
        print("MINECRAFT SERVER")
        print("-"*70)
        applier.update_minecraft(args.dry_run)

    # Update Fabric
    if update_all or args.fabric:
        print("\n" + "-"*70)
        print("FABRIC LOADER")
        print("-"*70)
        applier.update_fabric(args.dry_run)

    # Update mods
    if update_all or args.mods:
        print("\n" + "-"*70)
        print("MODS")
        print("-"*70)
        results = applier.update_mods(args.mods_dir, args.dry_run)

        if results:
            successful = sum(1 for success in results.values() if success)
            failed = len(results) - successful

            print(f"\n  Summary: {successful} successful, {failed} failed")

    print("\n" + "="*70)

    if args.dry_run:
        print("\n⚠ This was a dry run. Run without --dry-run to apply updates.")

    print()


if __name__ == '__main__':
    main()
